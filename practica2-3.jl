# 0:k - диапазон всех возможных значений элементов массива(a)
# num[i] - число значений n+1-i 
# n: k+n
# num = zeros(Int, k+1) - вектор из 0
# function sortkey(a, key) a- вектор некоторого типа, key - вектор ключей
#   ind = sortperm!(key) (переставили индексы)
#   return a[ind] срез массива , здесь именно копия a меняется, если хотим менять сам вектор a, то нужно написать @viewa[ind]
# end
# Задача 3 : из практики 1
# [A[:,j] for j in 1:size(A,2)] - вектор столбцов состоит из копий срезов , если хотим без копий, то нужно написать @viewA[]
# key = sum(A,dims = 1) - вектр состоит из сумм
# Как получить из вектора столбцов опять матрицу?
# [a d] - горизонтальная конконтинация , но массивы доожны быть одинаковы по размеру
# [a;d] - вертикальная конконтинация , но массивы доожны быть одинаковы по размеру
# hcat(a,b,c) - горизонтальная конконтинация
# vcat(a,b,c) - вертикалльная конконтинация
# hcat (a...) - a... - распаковка вектора - получили матрицу  
# Сортировка вставками:
# Пусть отсортировано k элементов, хотим отсортировать k+1 элемент
# Для этого копируем этот элемент и ищем между какими нужно вставить его, найдя сдвинаем все перед ним
# Сложность : наихудший случай - (n-1)*n/2, т.е. n^2 - если массив сначала отсортирован наоборот
# Но это можно улучшить с помощью быстрого поиска (бинарный)
# Можно взять середину этого вектора a, т.к. если элемент больше, то можно в левой половине не искать и т.д.  
# Но нам нужно не просто узнать какой половине принадлежит A, и есть ли он вообще в массиве, нам нужно найти A[i]<=a<A[i+1] такое i 
# Но лучша ли это по сложности зависит от того, что мы сравниваем  между собой
# Задача 1 : Написать программу для сортировки вставками без быстрого поиска
# Задача 2 : Написать программу для сортировки вставками с быстрым поиском
# задача 3 : Посмотреть возможности встроенных функций с помощью help
# sort!(a, by=abs) - сортировка по модулю
# lt = ... - 
# Можно так же выбрать алгоритм сортировку ( посмотреть, как это делается в help)
# Чтобы получить целую часть от деления надо написать div(a,b), а остаток от деления a%b
# Или написать a b а между ними написать \div<Tab>
# Задача 1 :
function insertsort!(A)
    n = length(A)

    for k = 2:n
        for i = 1:n-k
            if A[i]< A[k] <= A[i+1]
                insert!(A, i + 1,A[k])
            end
        end
    end
end
# Задача 2 :
function insertsort_poisk!(A)
    n = length(A)
    for k = 2:n
        if A[k-1]<A[k]<=A[k+1]
            t = k
        end
        index = poisk!(A[:t], A[t+1])
        insert!(A, index + 1 , A[t])
    end
    
end

function poisk!(b, c)
    n = length(b)
    l = 0
    while l<=n
        mid = (l+n)/2
        if b[mid] == c
            return mid
            break 
        else if b[mid] < c
            l = mid
            n = length(b)
        else 
            l = 0
            n = mid
        end
    end
    return mid
end
# Устойчивая сортировка в отличии от неустойчивой имеет постоянную вычислительную сложность
# Неустойчивая сортировка не может работать с большими объёмами данных из-за угрозы переполнения стека 